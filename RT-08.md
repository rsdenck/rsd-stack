# RT-08 — RELATÓRIO DE RECUPERAÇÃO ARQUITETURAL DA RSD-STACK

## 1. Visão Geral da Intervenção
A stack `rsd-stack` foi submetida a uma refatoração profunda para sair de um estado de "paralisia por hardening prematuro". A tentativa anterior de usar imagens Distroless e sistemas read-only globais sem o devido suporte de bibliotecas e caminhos resultou em falhas críticas de build e runtime.

## 2. Mudanças Implementadas

### 2.1 Imagem Base Unificada (`rsd/base-runtime:12`)
- **Arquitetura:** Debian 12 Slim.
- **Init System:** Introdução do `tini` como processo PID 1 para gestão correta de sinais e processos zumbis.
- **Padronização de Paths:** Criação da estrutura `/opt/rsd/` com diretórios `bin`, `config`, `certs`, `data`, `logs` e `tmp`.
- **Identidade:** Usuário `rsd` (UID 10001) padronizado em todas as imagens.

### 2.2 Refatoração de Dockerfiles
- **Fim do Distroless:** Substituído por imagens baseadas no `rsd/base-runtime:12`, garantindo a presença de `libc`, `libstdc++` e ferramentas de diagnóstico (`curl`, `nc`).
- **Entrypoints Oficiais:** Abandonada a execução direta de binários Java/Node. Agora utilizamos os scripts oficiais (`bin/elasticsearch`, `bin/kibana`, etc.) que possuem lógica interna de tuning e segurança.
- **Wazuh Nativo:** O Wazuh agora roda sobre Debian Slim, eliminando falhas de bibliotecas compartilhadas e permitindo que o `wazuh-control` gerencie seus daemons internos.

### 2.3 Orquestração (`docker-compose.yml`)
- **Volumes de Certificados:** Unificados para o path `/opt/rsd/certs`.
- **Healthchecks Reais:** Substituído o simples `java -version` por verificações funcionais (ex: `curl` na API do Elasticsearch com autenticação).
- **Recursos:** Ajuste de limites de CPU e Memória para refletir a carga real de uma stack ELK funcional.
- **Segurança Seletiva:** Mantido `cap_drop: ALL` com `cap_add` seletivos (CHOWN, SETUID, SETGID) apenas onde necessário para o bootstrap dos binários oficiais.

## 3. Riscos Eliminados
- **MODULE_NOT_FOUND:** Eliminado no Kibana ao usar o build oficial completo via COPY multi-stage.
- **TLS Read Error:** Resolvido pela padronização de caminhos e volumes.
- **Zumbi Processes:** Resolvido pelo uso do `tini`.
- **Instabilidade de Build:** O uso de uma base image local (`rsd/base-runtime`) garante previsibilidade.

## 4. Caminho para Hardening (Fase 2)
Com a stack funcional e estável, os próximos passos sugeridos são:
1.  **Read-Only seletivo:** Reativar `read_only: true` apenas nos diretórios de binários e configurações, mantendo `data` e `logs` como volumes/tmpfs.
2.  **Seccomp Profiles:** Criar perfis específicos para cada serviço em vez de apenas `cap_drop`.
3.  **Minimização da Base Image:** Remover ferramentas de diagnóstico (`curl`, `nc`) após a validação final da stack em produção.

**Status Final: APROVADO PARA BUILD E TESTE DE RUNTIME.**
