# RT-07 — RELATÓRIO ANALÍTICO DE FALHAS DE BUILD DA RSD-STACK

## 1. Visão Geral do Problema
O projeto `rsd-stack` encontra-se em um estado de **instabilidade crítica**. A tentativa de implementar um modelo de "Zero Trust Runtime" e "Sovereign Control" através de imagens Distroless e sistemas de arquivos read-only, embora louvável do ponto de vista de segurança, foi executada sem considerar as dependências operacionais profundas dos binários originais (Elasticsearch, Kibana, Wazuh).

**Impacto:**
- **Builds Quebrados:** Imagens incompletas por falhas no `cp -a` e falta de dependências nativas.
- **Runtime Failure:** Serviços em loop de restart por erros de permissão e caminhos de TLS inexistentes.
- **Bloqueio Operacional:** O sistema de validação de Supply Chain impede iterações rápidas para correção.

## 2. Análise Global da Stack
A stack sofre de um **acoplamento rígido de caminhos (hardcoded paths)** e uma **fragmentação de base images** que não compartilham a mesma estrutura de bibliotecas. 

- **Ordem de Build:** Não há um Makefile ou script de build orquestrado que garanta a ordem (ELS -> LGS -> KBN).
- **Dependências Cruzadas:** O `rsd-lgs` depende da saúde do `rsd-els`, mas o healthcheck do `rsd-els` está falhando por má configuração de TLS, travando toda a subida da stack.
- **Gargalo Arquitetural:** O uso de Distroless para aplicações complexas como Wazuh é um erro de design fundamental no estágio atual, pois o Wazuh não foi desenhado para ser "shell-less" e "root-less" de forma trivial.

## 3. Análise Detalhada por Imagem

### 3.1 rsd/els (Elasticsearch)
- **Base Image:** `gcr.io/distroless/java17-debian12`
- **Diagnóstico:** O Elasticsearch falha ao ler o `keystore` e certificados porque o volume de certificados estava mapeado fora do esperado pelo `elasticsearch.yml`.
- **Erro Estrutural:** Uso de `java` direto no `ENTRYPOINT` ignorando os wrappers de memória e segurança do próprio Elasticsearch (`bin/elasticsearch`).
- **Solução:** Sincronizar caminhos de TLS para `/opt/rsd/config/certs` e garantir que o `keystore` seja criado no build com as permissões corretas.

### 3.2 rsd/lgs (Logstash)
- **Base Image:** `gcr.io/distroless/java17-debian12`
- **Diagnóstico:** O `cp -a` no builder captura arquivos desnecessários e pode omitir bibliotecas JRuby essenciais que residem em caminhos ocultos.
- **Solução:** Mudar para uma abordagem de instalação via `apt` no builder e cópia seletiva de diretórios verificados.

### 3.3 rsd/kbn (Kibana)
- **Base Image:** `gcr.io/distroless/cc-debian12`
- **Diagnóstico:** Erro `MODULE_NOT_FOUND`. O Node.js não encontra o entrypoint porque o Kibana da Elastic utiliza symlinks e caminhos dinâmicos que o `cp -a` simples no Dockerfile Builder não resolve corretamente.
- **Solução:** Utilizar a imagem oficial como base e aplicar o hardening via `docker-tool` ou scripts de limpeza, em vez de tentar reconstruir o FS do Kibana manualmente no Distroless.

### 3.4 rsd/wzh (Wazuh)
- **Base Image:** `gcr.io/distroless/base-debian12`
- **Diagnóstico:** **ESTADO CRÍTICO.** O supervisor em Go tenta disparar daemons do Wazuh que exigem privilégios de root e acesso ao `/dev/log`, `/var/run`, etc. Em um container read-only e distroless, esses daemons morrem silenciosamente por falta de `libc` ou permissão de escrita.
- **Solução:** Abandonar Distroless para o Wazuh. Usar `debian-slim`, remover o que não for necessário e aplicar `AppArmor/Seccomp` em vez de tentar quebrar o binário original.

### 3.5 rsd/efw (Elastiflow)
- **Base Image:** `gcr.io/distroless/base-debian12`
- **Diagnóstico:** Funcional, mas instável devido a limites de memória (512MB) que são insuficientes para o coletor em alta carga.
- **Solução:** Aumentar limite para 1GB e validar aceitação de licença via ENV (já mitigado).

## 4. Problemas Sistêmicos Identificados
1.  **Inconsistência de TLS:** Cada imagem mapeia certificados em um lugar (`/opt/rsd/certs`, `/var/ossec/etc/certs`, `/opt/rsd/config/certs`). Isso é insustentável.
2.  **Healthchecks Frágeis:** Usar `java -version` não valida se o serviço está pronto, apenas se o binário existe. Isso causa falsos positivos/negativos.
3.  **Abstração Excessiva:** A tentativa de remover o shell (`/bin/sh`) via Distroless em apps que dependem de scripts de inicialização (como ELS e KBN) está gerando mais bugs do que segurança.

## 5. O QUE ESTÁ IMPEDINDO O BUILD (RESPOSTA DIRETA)
1.  **Caminhos de Destino Incorretos:** O builder copia arquivos para caminhos que o runtime não reconhece ou não tem permissão.
2.  **Falta de Bibliotecas Compartilhadas:** Apps em C++ (Kibana, Wazuh) falhando por falta de `libstdc++` e `glibc` completas no Distroless.
3.  **Permissões de Filesystem:** Containers `read_only` sem os devidos `tmpfs` montados para áreas de spool e lock.

## 6. SOLUÇÕES IMPOSITIVAS RECOMENDADAS
1.  **Padronização de Caminhos:** TODOS os certificados devem estar em `/opt/rsd/certs`.
2.  **Mudança de Base Images:**
    - ELS/LGS: Manter Java Distroless, mas ajustar `ENTRYPOINT`.
    - KBN: Migrar para `cc-debian12` ou imagem oficial com hardening.
    - WZH: Migrar para `debian-slim`.
3.  **Build Orquestrado:** Criar um `ops/build-all.ps1` que valide cada imagem antes de atualizar o `images.sha256`.
4.  **Refatoração do docker-compose.yml:** Unificar volumes e simplificar healthchecks para chamadas HTTP (onde disponível).

## 7. Próximos Passos Técnicos
1.  **Correção do rsd/els:** Validar TLS e Healthcheck.
2.  **Rebuild do rsd/kbn:** Corrigir o entrypoint do Node.
3.  **Migração do rsd/wzh:** Sair do Distroless para garantir funcionalidade.
4.  **Validação de Ponta a Ponta:** Executar `ops/stack-up.ps1` e garantir que `rsd-els` chegue ao estado `healthy`.
